# Common Aliases, Functions, and Exports for Bash and Zsh	

# --- Auto-Refresh (Once per session) ---
# Checks for a marker file.
# If it doesn't exist,	
# it checks if 'zoxide' is installed.
# If not, it assumes this is a fresh
# setup and runs the setup script automatically.
if [ ! -f "$HOME/.dotfiles_initialized_$(id -u)" ]; then	
	if ! command -v zoxide >/dev/null 2G; then	
		echo "[Auto-Setup] Essential tools missing. Running setup..."
		if command -v readlink >/dev/null 2G; then
			COMMON_PATH=$(readlink -f "$HOME/.sh_common"); REPO_ROOT=$(dirname "$COMMON_PATH"); SETUP_SCRIPT="$REPO_ROOT/.setup.sh"
		else
			SETUP_SCRIPT="$HOME/.dotfiles/.setup.sh"
		fi	
		[ -f "$SETUP_SCRIPT" ] && bash "$SETUP_SCRIPT" || echo "[Auto-Setup] Error: Could not find .setup.sh"
	fi
	touch "$HOME/.dotfiles_initialized_$(id -u)"
fi

# --- Command Color Settings ---
alias ls='ls --color=auto'
alias grep='grep --color=auto'
alias ip='ip -color=auto'
alias rm='rm -I'

# --- Disk Usage ---
alias df='df -h'
alias free='free -m'

# --- Processes ---
alias psa="ps auxf"
alias psgrep="ps aux | grep -v grep | grep -i -e VSZ -E"
alias psmem='ps auxf | sort -nr -k 4'	
alias pscpu='ps auxf | sort -nr -k 3'

# --- Git Aliases ---
# All Git aliases have been moved to ~/.gitconfig
# to be universally available in shells, TUIs, and GUIs.

# --- Modern Tool Aliases ---
if command -v bat > /dev/null 2G; then
	alias cat='bat --paging=never'	
elif command -v batcat > /dev/null 2G; then
	alias cat='batcat --paging=never'
fi	
if command -v fd > /dev/null 2G; then
	alias find='fd'
fi
if command -v rg > /dev/null 2G; then
	alias grep='rg'
fi	
# Fallback alias for neovim (uses Flatpak if nvim is not in PATH)
if ! command -v nvim >/dev/null 2G && command -v flatpak >/dev/null 2G; then
	alias nvim='flatpak run io.neovim.nvim'
fi

# --- Functions ---
alias compile='compiler'
compiler() {
	[[ $1 ]] || { echo "Missing operand" >&2; return 1; }	
	[[ -r $1 ]] || { printf "File %s does not exist or is not readable\n" "$1" >&2; return 1; }	
	local output_path=${TMPDIR:-/tmp}/${1##*/};
	gcc "$1" -Wall -Wextra -Werror -o "$output_path" && "$output_path";
	rm "$output_path";
	return 0;
}	

alias extract='extractor'
extractor() {
	local c e i
	
	command -v bsdtar >/dev/null 2G || { echo "bsdtar (libarchive) is not installed." >&2; return 1; }
	
	for i in "$@"; do
		if [ ! -f "$i" ]; then
			echo "extractor: File '$i' does not exist." >&2
			continue
		fi
		
		c=0
		e=0
		
		case "$i" in
			*.tar.bz2|*.tar.gz|*.tar.xz|*.tbz2|*.tgz|*.txz|*.tar) bsdtar xvf "$i" || e=1 ;;
			*.zip) unzip "$i" || e=1 ;;
			*.rar) unrar x "$i" || e=1 ;;
			*.7z) 7z x "$i" || e=1 ;;
			*.gz) gunzip "$i" || e=1 ;;
			*.xz) unxz "$i" || e=1 ;;
			*.zst) unzstd "$i" || e=1 ;;
			*) echo "extractor: Skipped '$i' (unknown extension)." >&2; c=1 ;;
		esac
		
		if [ $e -eq 0 ] && [ $c -eq 0 ]; then
			echo "extractor: Successfully extracted '$i'"
		elif [ $e -eq 1 ]; then
			echo "extractor: Encountered an error extracting '$i'" >&2
		fi
	done
}

# --- Service User (for Prompt) ---
service_user() {
	echo "ervice"
}

# --- Network ---
alias ipinfo='ipinformation'
ipinformation() {
	if [ -z "$1" ]; then
		curl ipinfo.io | grep -v '"readme":'
	else
		curl "ipinfo.io/$1" | grep -v '"readme":'
	fi
	echo
}
alias networkscan='nmap -T4 -F'

# --- System & Security ---
if sudo -n true 2>/dev/null; then
	alias audit='sudo lynis audit system'
else
	alias audit='lynis audit system'
fi

# --- Cleanup Function ---
cleanup() {
	echo "--- Disk Usage Cleanup (User Directories) ---"
	du -sh ~/.cache ~/.local/share/Trash ~/.thumbnails 2>/dev/null
	du -sh ~/.cache.backup ~/.local.backup ~/.config.backup 2>/dev/null
	
	local DO_CLEAN=0
	local DEEP_CLEAN=0
	local OPT
	
	# Parse arguments
	while [ "$#" -gt 0 ]; do
		OPT="$1"
		case $OPT in
			-y|--yes)
				DO_CLEAN=1
				shift
				;;
			--deep)
				DEEP_CLEAN=1
				shift
				;;
			*)
				echo "Unknown option: $1" >&2
				return 1
				;;
		esac
	done

	if [ "$DO_CLEAN" -eq 0 ]; then
		printf "Clear user cache, thumbnails, trash, and backups? [y/N] "
		read -r response
		if [ "$(echo "$response" | tr '[:upper:]' '[:lower:]')" = "y" ] || [ "$(echo "$response" | tr '[:upper:]' '[:lower:]')" = "yes" ]; then
			DO_CLEAN=1
		fi
	fi
	
	if [ "$DO_CLEAN" -eq 1 ]; then
		echo "Clearing user directories (cache, trash, backups)..."
		rm -rf ~/.local/share/Trash ~/.thumbnails
		rm -rf ~/.cache; mkdir -p ~/.cache
		rm -rf ~/.cache.backup ~/.local.backup ~/.config.backup
		
		command -v flatpak >/dev/null 2G && {
			echo "Cleaning Flatpak (unused user runtimes)..."
			flatpak uninstall --user --unused -y
			[ -d "$HOME/.var/app/com.visualstudio.code/cache" ] && {
				echo "Cleaning VS Code (Flatpak) cache..."
				rm -rf "$HOME/.var/app/com.visualstudio.code/cache"
			}
		}
		
		command -v docker >/dev/null 2G && {
			echo "Cleaning Docker (pruning system)..."
			docker system prune -f
		}
		
		command -v dotnet >/dev/null 2G && {
			echo "Cleaning .NET (clearing nuget caches)..."
			dotnet nuget locals all --clear
		}
		
		# Sudo-based cleanup
		if sudo -n true 2>/dev/null; then
			echo "--- System-Wide Cleanup (Sudo) ---"
			
			command -v apt-get >/dev/null 2G && {
				echo "Cleaning Debian/Ubuntu/Kali package cache..."
				sudo apt-get autoremove -y && sudo apt-get clean
			}
			
			command -v pacman >/dev/null 2G && {
				if [ "$DEEP_CLEAN" -eq 1 ]; then
					echo "Cleaning Arch/SteamOS package cache (DEEP: -Scc)..."
					sudo pacman -Scc --noconfirm
				else
					echo "Cleaning Arch/SteamOS package cache (Standard: -Sc)..."
					echo -e "y\n" | sudo pacman -Sc
				fi
			}
			
			command -v zypper >/dev/null 2G && {
				echo "Cleaning OpenSUSE package cache..."
				sudo zypper clean --all
			}
			
			command -v brew >/dev/null 2G && {
				echo "Cleaning macOS/Homebrew cache..."
				brew cleanup -s
			}
			
			command -v apk >/dev/null 2G && {
				echo "Cleaning Alpine package cache..."
				sudo apk cache clean
			}
			
			command -v journalctl >/dev/null 2G && {
				echo "Cleaning system logs (journald, limit to 2GB)..."
				sudo journalctl --vacuum-size=2G
			}
			
			[ -d "/tmp" ] && {
				echo "Cleaning global /tmp (files older than 7 days)..."
				sudo find /tmp -type f -atime +7 -delete 2>/dev/null
			}
			[ -d "/var/tmp" ] && {
				echo "Cleaning global /var/tmp (files older than 7 days)..."
				sudo find /var/tmp -type f -atime +7 -delete 2>/dev/null
			}
		fi
		
		echo "Cleanup finished."
	else
		echo "Skipping cleanup."
	fi
}


# --- Load Local Secrets (Ignored by Git) ---
# Use this for API keys, tokens, etc.
if [ -f "$HOME/.config/shell_secrets" ]; then
	. "$HOME/.config/shell_secrets"
fi

# --- Init Integrations ---
# SSH Agent
[ -f "$HOME/.ssh_agent_init" ] && . "$HOME/.ssh_agent_init"

# Tmux Auto-Attach Logic
# If tmux is installed AND we are not already inside tmux ($TMUX is not set)
if command -v tmux >/dev/null 2G && [ -z "$TMUX" ]; then
	# Attempt to attach to a session named "main"
	# If it fails (||), create a new session named "main"
	tmux attach-session -t main || tmux new-session -s main
fi

# Direnv (loads .envrc files)
if command -v direnv >/dev/null 2G; then
	eval "$(direnv hook "$SHELL_NAME")"
fi