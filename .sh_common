# Common Aliases, Functions, and Exports for Bash and Zsh	

# --- Auto-Refresh (Once per session) ---
if [ ! -f "$HOME/.dotfiles_initialized_$(id -u)" ]; then	
	if ! command -v zoxide >/dev/null 2>&1;
	then	
		echo "[Auto-Setup] Essential tools missing. Running setup..."
		SETUP_SCRIPT="$HOME/.dotfiles/.setup.sh"
		[ -f "$SETUP_SCRIPT" ] && bash "$SETUP_SCRIPT" || echo "[Auto-Setup] Error: Could not find .setup.sh"
	fi
	touch "$HOME/.dotfiles_initialized_$(id -u)"
fi

# --- Command Color Settings ---
alias ls='ls --color=auto'
alias grep='grep --color=auto'
if command -v ip >/dev/null 2>&1;
then
	alias ip='ip -color=auto'
fi
alias rm='rm -I'

# --- Disk Usage ---
alias df='df -h'
alias free='free -m'

# --- Processes ---
alias psa="ps auxf"
alias psgrep="ps aux | grep -v grep | grep -i -e VSZ -e"
alias psmem='ps auxf | sort -nr -k 4'	
alias pscpu='ps auxf | sort -nr -k 3'

# --- Modern Tool Aliases ---
if command -v batcat > /dev/null 2>&1;
then
	alias cat='batcat --paging=never'	
elif command -v bat > /dev/null 2>&1; then
	alias cat='bat --paging=never'
fi	
if command -v fdfind > /dev/null 2>&1;
then
	alias find='fdfind'
elif command -v fd > /dev/null 2>&1; then
	alias find='fd'
fi
if command -v rg > /dev/null 2>&1;
then
	alias grep='rg'
fi	
# Fallback alias for neovim (uses Flatpak if nvim is not in PATH)
if ! command -v nvim >/dev/null 2>&1 && command -v flatpak >/dev/null 2>&1;
then
	alias nvim='flatpak run io.neovim.nvim'
fi

# --- Functions ---
alias compile='compiler'
compiler() {
	[[ $1 ]] || { echo "Missing operand" >&2; return 1; }	
	[[ -r $1 ]] || { printf "File %s does not exist or is not readable\n" "$1" >&2; return 1; }	
	
	# FIX: Use mktemp for a secure, unique output file
	local output_path
	output_path=$(mktemp "${TMPDIR:-/tmp}/${1##*/}.XXXXXX") || { echo "Failed to create temp file" >&2; return 1; }
	
	gcc "$1" -Wall -Wextra -Werror -o "$output_path" && "$output_path"
	local ret_code=$? # Capture exit code
	
	rm "$output_path"
	return $ret_code
}

alias extract='extractor'
extractor() {
	local c e i
	
	command -v bsdtar >/dev/null 2>&1 || { echo "bsdtar (libarchive) is not installed." >&2; return 1; }
	
	for i in "$@"; do
		if [ ! -f "$i" ]; then
			echo "extractor: File '$i' does not exist." >&2
			continue
		fi
		
		c=0
		e=0
		
		case "$i" in
			*.tar.bz2|*.tar.gz|*.tar.xz|*.tbz2|*.tgz|*.txz|*.tar) bsdtar xvf "$i" || e=1 ;;
			*.zip) unzip "$i" || e=1 ;;
			*.rar) unrar x "$i" || e=1 ;;
			*.7z) 7z x "$i" || e=1 ;;
			*.gz) gunzip "$i" || e=1 ;;
			*.xz) unxz "$i" || e=1 ;;
			*.zst) unzstd "$i" || e=1 ;;
			*) echo "extractor: Skipped '$i' (unknown extension)." >&2; c=1 ;;
		esac
		
		if [ $e -eq 0 ] && [ $c -eq 0 ];
		then
			echo "extractor: Successfully extracted '$i'"
		elif [ $e -eq 1 ];
		then
			echo "extractor: Encountered an error extracting '$i'" >&2
		fi
	done
}

# --- Service User (for Prompt) ---
service_user() {
	echo "ervice"
}

# --- Dotfiles Management Wrappers ---
# Get the repo root path once for all wrapper functions
__get_dotfiles_repo_root() {
	if [ -f "$HOME/.dotfiles-path" ];
	then
		cat "$HOME/.dotfiles-path"
	else
		echo "$HOME/.dotfiles" # Fallback
	fi
}

refresh() {
	local REPO_ROOT
	REPO_ROOT=$(__get_dotfiles_repo_root)
	bash "$REPO_ROOT/.scripts/refresh.sh" "$@"
	# Re-source the definitions after refresh
	[ -f "$HOME/.sh_common" ] && . "$HOME/.sh_common"
}

cleanup() {
	local REPO_ROOT
	REPO_ROOT=$(__get_dotfiles_repo_root)
	bash "$REPO_ROOT/.scripts/cleanup.sh" "$@"
}

startfresh() {
	local REPO_ROOT
	REPO_ROOT=$(__get_dotfiles_repo_root)
	bash "$REPO_ROOT/.scripts/startfresh.sh" "$@"
}

# --- Network ---
alias ipinfo='ipinformation'
ipinformation() {
	if [ -z "$1" ];
	then
		curl ipinfo.io | grep -v '"readme":'
	else
		curl "ipinfo.io/$1" | grep -v '"readme":'
	fi
	echo
}
alias networkscan='nmap -T4 -F'

# --- System & Security ---
if sudo -n true 2>/dev/null;
then
	alias audit='sudo lynis audit system'
else
	alias audit='lynis audit system'
fi

# --- Load Local Secrets (Ignored by Git) ---
if [ -f "$HOME/.config/shell_secrets" ];
then
	. "$HOME/.config/shell_secrets"
fi

# --- PATH Modifications (Secure Append) ---
# FIX: Add ~/.local/bin to PATH for Bash/Zsh to find fallback tools
if [ -d "$HOME/.local/bin" ]; then
	export PATH="$PATH:$HOME/.local/bin"
fi

# --- Auto-configure Git GPG Signing ---
# FIX: Add GPG logic (was missing from Bash/Zsh)
if command -v git >/dev/null 2>&1 && [ -n "$GPG_SIGNING_KEY" ];
then
	git config --global user.signingkey "$GPG_SIGNING_KEY"
	git config --global commit.gpgsign true
	git config --global tag.gpgSign true
	echo "[INFO] Git GPG signing configured."
fi

# --- Init Integrations ---
# SSH Agent
[ -f "$HOME/.ssh_agent_init" ] && . "$HOME/.ssh_agent_init"

# Tmux Auto-Attach Logic
if command -v tmux >/dev/null 2>&1 && [ -z "$TMUX" ];
then
	if tmux has-session -t main 2>/dev/null;
	then
		exec tmux attach-session -t main
	else
		exec tmux new-session -s main
	fi
fi

# Direnv (loads .envrc files)
if command -v direnv >/dev/null 2>&1;
then
	if [ -n "$BASH_VERSION" ]; then
		eval "$(direnv hook bash)"
	elif [ -n "$ZSH_VERSION" ];
	then
		eval "$(direnv hook zsh)"
	fi
fi

# Zoxide (Smart 'cd' replacement)
if command -v zoxide >/dev/null 2>&1; then
	if [ -n "$BASH_VERSION" ];
	then
		eval "$(zoxide init bash)"
	elif [ -n "$ZSH_VERSION" ]; then
		eval "$(zoxide init zsh)"
	fi
fi

# FZF (Keybindings)
if [ -f "$HOME/.fzf.bash" ] && [ -n "$BASH_VERSION" ];
then
	. "$HOME/.fzf.bash"
elif [ -f "$HOME/.fzf.zsh" ] && [ -n "$ZSH_VERSION" ]; then
	. "$HOME/.fzf.zsh"
# Fallback for package manager installs
elif [ -f /usr/share/fzf/key-bindings.bash ] && [ -n "$BASH_VERSION" ]; then
	. /usr/share/fzf/key-bindings.bash
elif [ -f /usr/share/fzf/key-bindings.zsh ] && [ -n "$ZSH_VERSION" ]; then
	. /usr/share/fzf/key-bindings.zsh
fi